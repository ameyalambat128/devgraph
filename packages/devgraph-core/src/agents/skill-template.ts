import type { ApiBlock, Devgraph, EnvBlock, ServiceBlock } from '../index.js';
import { generateServiceMermaid } from '../index.js';
import { getLandmarkDescription, type InferredData, mergeCommands } from './inference.js';

export interface ServiceSkillTemplateData {
  service: ServiceBlock & { apis?: ApiBlock[]; env?: EnvBlock[] };
  graph: Devgraph;
  inferred: InferredData;
  servicePath?: string;
  bestEffort: boolean;
  downstreamConsumers: string[];
}

// --- Layer 1: Overview Skill ---

export function renderOverviewSkillMd(graph: Devgraph): string {
  const serviceCount = Object.keys(graph.services).length;
  const lines: string[] = [];

  // Frontmatter
  lines.push('---');
  lines.push('name: querying-architecture');
  lines.push('description: >');
  lines.push('  Queries and validates service architecture using the devgraph CLI.');
  lines.push('  Use when checking service dependencies, analyzing blast radius of changes,');
  lines.push('  validating architecture rules, finding API routes between services,');
  lines.push('  or coordinating cross-service work. Also use before adding new');
  lines.push('  dependencies or modifying service contracts.');
  lines.push(`  This project has ${serviceCount} service(s).`);
  lines.push('---');
  lines.push('');

  // Body
  lines.push('# Architecture Queries');
  lines.push('');

  lines.push('## Check what a change affects');
  lines.push('');
  lines.push('```bash');
  lines.push('devgraph impact <service> --json');
  lines.push('```');
  lines.push('');
  lines.push('Returns directConsumers, transitiveConsumers, and affectedApiRouteCount.');
  lines.push('High count → consider migration strategy over breaking change.');
  lines.push('');

  lines.push('## Validate architecture');
  lines.push('');
  lines.push('```bash');
  lines.push('devgraph validate --json');
  lines.push('```');
  lines.push('');
  lines.push('Exit 0 = clean. Exit 1 = violations. Fix all violations before PR.');
  lines.push('');

  lines.push('## Get the run plan for local development');
  lines.push('');
  lines.push('```bash');
  lines.push('devgraph run <service>');
  lines.push('```');
  lines.push('');
  lines.push('Shows services to start in dependency order with exact commands.');
  lines.push('');

  lines.push('## Coordinate cross-service changes');
  lines.push('');
  lines.push('```bash');
  lines.push('devgraph coordinate <service> --json');
  lines.push('```');
  lines.push('');
  lines.push('Returns tasks for each affected service when making breaking changes.');
  lines.push('');

  lines.push('## Full graph');
  lines.push('');
  lines.push('See [references/ARCHITECTURE.md](references/ARCHITECTURE.md) for the complete service dependency graph.');
  lines.push('');
  lines.push('See [references/SERVICES.md](references/SERVICES.md) for a quick-reference of all services.');
  lines.push('');

  return lines.join('\n');
}

export function renderArchitectureReference(graph: Devgraph): string {
  const lines: string[] = [];

  lines.push('# Architecture');
  lines.push('');
  lines.push('> Auto-generated by DevGraph. Do not edit manually.');
  lines.push('');

  // Mermaid diagram
  lines.push('## Dependency Graph');
  lines.push('');
  lines.push('```mermaid');
  lines.push(generateServiceMermaid(graph).trim());
  lines.push('```');
  lines.push('');

  // Service list
  const serviceNames = Object.keys(graph.services).sort();
  lines.push('## Services');
  lines.push('');
  lines.push('| Service | Type | Dependencies |');
  lines.push('|---------|------|-------------|');
  for (const name of serviceNames) {
    const service = graph.services[name];
    const deps = service.depends?.length ? service.depends.join(', ') : '—';
    lines.push(`| ${name} | ${service.type} | ${deps} |`);
  }
  lines.push('');

  return lines.join('\n');
}

export function renderServicesReference(
  graph: Devgraph,
  inferredDataMap: Map<string, InferredData>
): string {
  const lines: string[] = [];

  lines.push('# Services Quick Reference');
  lines.push('');
  lines.push('> Auto-generated by DevGraph. Do not edit manually.');
  lines.push('');

  const serviceNames = Object.keys(graph.services).sort();

  lines.push('| Service | Type | Package Manager | Commands | Ports |');
  lines.push('|---------|------|-----------------|----------|-------|');
  for (const name of serviceNames) {
    const service = graph.services[name];
    const inferred = inferredDataMap.get(name);
    const packageManager = inferred?.packageManager ?? '—';
    const mergedCommands = mergeCommands(service.commands, inferred?.commands ?? {});
    const commandList = Object.keys(mergedCommands).join(', ') || '—';
    const ports = service.ports?.join(', ') || '—';
    lines.push(`| ${name} | ${service.type} | ${packageManager} | ${commandList} | ${ports} |`);
  }
  lines.push('');

  return lines.join('\n');
}

// --- Layer 2: Per-Service Skills ---

export function renderServiceSkillMd(data: ServiceSkillTemplateData): string {
  const { service, graph, inferred, servicePath, bestEffort, downstreamConsumers } = data;
  const lines: string[] = [];
  const skillName = `${service.name}-context`;

  // Frontmatter
  lines.push('---');
  lines.push(`name: ${skillName}`);
  lines.push('description: >');
  lines.push(`  Provides development context for the ${service.name} service.`);
  if (servicePath) {
    lines.push(`  Use when editing files in ${servicePath}/, working on`);
  } else {
    lines.push('  Use when working on');
  }
  lines.push(`  ${service.name} or when the user mentions ${service.name}.`);
  lines.push(`  Includes commands, dependencies, and architecture context.`);
  lines.push('---');
  lines.push('');

  // Header with quick reference
  lines.push(`# ${service.name}`);
  lines.push('');
  const quickRefParts = [`Type: ${service.type}`];
  if (inferred.packageManager) quickRefParts.push(`Package manager: ${inferred.packageManager}`);
  if (servicePath) quickRefParts.push(`Location: ${servicePath}/`);
  lines.push(`- ${quickRefParts.join(' | ')}`);
  lines.push('');

  // Commands table
  const mergedCommands = mergeCommands(service.commands, inferred.commands);
  const commandKeys = ['dev', 'build', 'test', 'start', 'lint'];

  if (Object.keys(mergedCommands).length > 0) {
    lines.push('## Commands');
    lines.push('');
    lines.push('| Task | Command |');
    lines.push('|------|---------|');
    for (const key of commandKeys) {
      if (mergedCommands[key]) {
        lines.push(`| ${key} | \`${mergedCommands[key]}\` |`);
      }
    }
    for (const [key, value] of Object.entries(mergedCommands)) {
      if (!commandKeys.includes(key)) {
        lines.push(`| ${key} | \`${value}\` |`);
      }
    }
    lines.push('');
  } else if (bestEffort) {
    lines.push('## Commands');
    lines.push('');
    lines.push('<!-- TODO: Add commands -->');
    lines.push('');
  }

  // Before submitting changes
  const checkCommands: string[] = [];
  if (mergedCommands.lint) checkCommands.push(mergedCommands.lint);
  if (mergedCommands.test) checkCommands.push(mergedCommands.test);
  if (mergedCommands.build) checkCommands.push(mergedCommands.build);

  if (checkCommands.length > 0) {
    lines.push('## Before submitting changes');
    lines.push('');
    lines.push(`\`${checkCommands.join(' && ')}\``);
    lines.push('');
  }

  // Dependencies
  if (service.depends && service.depends.length > 0) {
    lines.push('## Dependencies');
    lines.push('');
    for (const dep of service.depends) {
      const depService = graph.services[dep];
      if (depService) {
        lines.push(`- **${dep}** (${depService.type})`);
      } else {
        lines.push(`- **${dep}** (external)`);
      }
    }
    lines.push('');
  }

  // Downstream consumers
  if (downstreamConsumers.length > 0) {
    lines.push('## Downstream consumers');
    lines.push('');
    for (const consumer of downstreamConsumers) {
      lines.push(`- **${consumer}**`);
    }
    lines.push('');
  }

  // API routes — link to reference if present
  const hasAPIs = service.apis && service.apis.length > 0 &&
    service.apis.some(api => Object.keys(api.routes || {}).length > 0);
  if (hasAPIs) {
    lines.push('## API routes');
    lines.push('');
    lines.push('See [references/ROUTES.md](references/ROUTES.md) for full route definitions.');
    lines.push('');
  }

  // Key directories
  if (inferred.landmarks.length > 0) {
    lines.push('## Key directories');
    lines.push('');
    for (const landmark of inferred.landmarks) {
      const desc = getLandmarkDescription(landmark);
      lines.push(`- \`${landmark}/\` — ${desc}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

export function renderRoutesReference(
  service: ServiceBlock & { apis?: ApiBlock[] }
): string {
  const lines: string[] = [];

  lines.push(`# ${service.name} — API Routes`);
  lines.push('');
  lines.push('> Auto-generated by DevGraph. Do not edit manually.');
  lines.push('');

  lines.push('| Method | Path | Description |');
  lines.push('|--------|------|-------------|');
  for (const api of service.apis ?? []) {
    for (const [route, desc] of Object.entries(api.routes || {})) {
      const parts = route.split(' ');
      const method = parts.length > 1 ? parts[0] : 'GET';
      const routePath = parts.length > 1 ? parts.slice(1).join(' ') : route;
      const description = typeof desc === 'string' && desc ? desc : '—';
      lines.push(`| \`${method}\` | \`${routePath}\` | ${description} |`);
    }
  }
  lines.push('');

  return lines.join('\n');
}
