import type { Devgraph, ServiceWithDetails } from '@/types/graph';

/**
 * Generate summary markdown from a Devgraph
 */
export function generateSummary(graph: Devgraph): string {
  const lines: string[] = [];
  const services = Object.values(graph.services);
  const timestamp = new Date().toISOString().split('T')[0];

  lines.push('# DevGraph Summary');
  lines.push('');
  lines.push(`> Generated by DevGraph Studio on ${timestamp}`);
  lines.push('');

  const totalApis = services.reduce(
    (acc, svc) =>
      acc + (svc.apis?.reduce((a, api) => a + Object.keys(api.routes || {}).length, 0) || 0),
    0
  );
  const totalEnvVars = services.reduce(
    (acc, svc) =>
      acc + (svc.env?.reduce((a, env) => a + Object.keys(env.vars || {}).length, 0) || 0),
    0
  );

  lines.push(`**${services.length}** services | **${totalApis}** API routes | **${totalEnvVars}** env vars`);
  lines.push('');
  lines.push('---');
  lines.push('');

  lines.push('## Services');
  lines.push('');

  if (!services.length) {
    lines.push('No services found.');
  } else {
    lines.push('| Service | Type | Dependencies |');
    lines.push('|---------|------|--------------|');
    for (const svc of services) {
      const deps = svc.depends?.join(', ') || '—';
      lines.push(`| **${svc.name}** | ${svc.type} | ${deps} |`);
    }
  }
  lines.push('');

  for (const svc of services) {
    lines.push(`### ${svc.name}`);
    lines.push('');

    if (svc.commands && Object.keys(svc.commands).length) {
      lines.push('**Commands:**');
      lines.push('```bash');
      for (const [cmd, script] of Object.entries(svc.commands)) {
        lines.push(`${script}  # ${cmd}`);
      }
      lines.push('```');
      lines.push('');
    }

    if (svc.apis && svc.apis.length) {
      lines.push('**API Routes:**');
      lines.push('| Route | Description |');
      lines.push('|-------|-------------|');
      for (const api of svc.apis) {
        for (const [route, desc] of Object.entries(api.routes || {})) {
          const description = typeof desc === 'string' ? desc : '—';
          lines.push(`| \`${route}\` | ${description} |`);
        }
      }
      lines.push('');
    }

    if (svc.env && svc.env.length) {
      lines.push('**Environment Variables:**');
      lines.push('| Variable | Default |');
      lines.push('|----------|---------|');
      for (const env of svc.env) {
        for (const [key, val] of Object.entries(env.vars)) {
          lines.push(`| \`${key}\` | \`${val}\` |`);
        }
      }
      lines.push('');
    }
  }

  return lines.join('\n') + '\n';
}

/**
 * Generate agent context for a single service
 */
export function generateAgentContext(service: ServiceWithDetails, graph: Devgraph): string {
  const lines: string[] = [];
  const timestamp = new Date().toISOString().split('T')[0];

  lines.push(`# AGENTS.md — ${service.name}`);
  lines.push('');
  lines.push(`> Auto-generated by DevGraph Studio on ${timestamp}`);
  lines.push('');

  lines.push('## Overview');
  lines.push('');
  lines.push(`**${service.name}** is a \`${service.type}\` service.`);
  if (service.depends && service.depends.length) {
    lines.push(`This service depends on: ${service.depends.map((d) => `\`${d}\``).join(', ')}.`);
  }
  lines.push('');

  if (service.commands && Object.keys(service.commands).length) {
    lines.push('## Quick Start');
    lines.push('');
    lines.push('```bash');
    for (const [cmd, script] of Object.entries(service.commands)) {
      lines.push(`${script}  # ${cmd}`);
    }
    lines.push('```');
    lines.push('');
  }

  if (service.apis && service.apis.length) {
    lines.push('## API Endpoints');
    lines.push('');
    lines.push('| Method | Path | Description |');
    lines.push('|--------|------|-------------|');
    for (const api of service.apis) {
      for (const [route, desc] of Object.entries(api.routes || {})) {
        const parts = route.split(' ');
        const method = parts.length > 1 ? parts[0] : 'GET';
        const path = parts.length > 1 ? parts.slice(1).join(' ') : route;
        const description = typeof desc === 'string' && desc ? desc : '—';
        lines.push(`| \`${method}\` | \`${path}\` | ${description} |`);
      }
    }
    lines.push('');
  }

  if (service.env && service.env.length) {
    lines.push('## Environment Variables');
    lines.push('');
    lines.push('| Variable | Default |');
    lines.push('|----------|---------|');
    for (const env of service.env) {
      for (const [key, val] of Object.entries(env.vars)) {
        lines.push(`| \`${key}\` | \`${val}\` |`);
      }
    }
    lines.push('');
  }

  if (service.depends && service.depends.length) {
    lines.push('## Dependencies');
    lines.push('');
    lines.push('This service communicates with:');
    for (const dep of service.depends) {
      const depSvc = graph.services[dep];
      if (depSvc) {
        lines.push(`- **${dep}** (\`${depSvc.type}\`)`);
      } else {
        lines.push(`- **${dep}**`);
      }
    }
    lines.push('');
  }

  return lines.join('\n').trim() + '\n';
}

/**
 * Generate Mermaid diagram from a Devgraph
 */
export function generateMermaid(graph: Devgraph): string {
  const lines = ['graph LR'];
  const services = Object.keys(graph.services).sort();
  const declared = new Set<string>();

  const sanitizeId = (name: string): string => {
    return name.replace(/[^a-zA-Z0-9_]/g, '_');
  };

  for (const name of services) {
    const svc = graph.services[name];
    const id = sanitizeId(name);
    const label = `${name} (${svc.type})`;
    lines.push(`${id}["${label}"]`);
    declared.add(id);

    if (svc.depends && svc.depends.length) {
      const deps = [...svc.depends].sort();
      for (const dep of deps) {
        const depId = sanitizeId(dep);
        const depSvc = graph.services[dep];
        if (depSvc && !declared.has(depId)) {
          lines.push(`${depId}["${dep} (${depSvc.type})"]`);
          declared.add(depId);
        }
        lines.push(`${id} --> ${depId}`);
      }
    }
  }

  return lines.join('\n') + '\n';
}

/**
 * Download content as a file
 */
export function downloadFile(content: string, filename: string, mimeType = 'text/plain') {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Copy content to clipboard
 */
export async function copyToClipboard(content: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch {
    return false;
  }
}
